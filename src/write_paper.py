#!/usr/bin/env python3
"""
Refactored Academic Paper Generator with Global Sentence-Level Citations.

This script provides a clean command-line interface to the refactored PaperSolver class,
implementing sophisticated global citation management for academic papers.

Key Features:
- Global sentence-level citation deduplication across sections
- Sequential citation numbering with proper References section
- Clean separation between traditional and global citation approaches
- Comprehensive paper validation and quality reporting

Usage:
    python src/write_paper_re.py -q question.txt -r results.md --output paper.md

Examples:
    # Basic usage with global citations (default)
    python src/write_paper_re.py -q question.txt -r results.md
    
    # Use traditional citations instead
    python src/write_paper_re.py -q question.txt -r results.md --traditional
    
    # Specify custom parameters
    python src/write_paper_re.py -q question.txt -r results.md -o paper.md -w 5000 --model openai/gpt-4o
    
    # Direct text input
    python src/write_paper_re.py --question "How do T-cells work?" --results "Analysis shows..." --verbose
"""

import argparse
import os
import sys
from pathlib import Path

# Add src to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

from src.agent.writer import PaperSolver


def load_content_from_file(file_path: str) -> str:
    """
    Load content from a file with proper error handling.
    
    Args:
        file_path (str): Path to the file
        
    Returns:
        str: File content
        
    Raises:
        FileNotFoundError: If file doesn't exist
        IOError: If file can't be read
    """
    try:
        file_path = Path(file_path)
        if not file_path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read().strip()
        
        if not content:
            raise ValueError(f"File is empty: {file_path}")
        
        print(f"   Loaded {len(content)} characters from {file_path.name}")
        return content
        
    except Exception as e:
        print(f"âŒ Error loading file {file_path}: {e}")
        raise


def save_paper_with_metadata(
    paper_content: str, 
    output_path: str, 
    research_question: str, 
    scientist_findings: str, 
    validation: dict,
) -> str:
    """
    Save paper with comprehensive metadata header.
    
    Args:
        paper_content (str): The generated paper content
        output_path (str): Path where to save the paper
        research_question (str): Original research question
        scientist_findings (str): Original scientist findings
        validation (dict): Paper validation results
        
    Returns:
        str: Path to saved file
    """
    try:
        # Create metadata header
        metadata_header = f"""<!--
PAPER GENERATION METADATA
========================
Generated by: Academic Paper Generator
Word Count: {validation.get('word_count', 'Unknown')}
Citations: {validation.get('citation_count', 0)}
Figures: {validation.get('figure_suggestions', 0)}
Structure Complete: {validation.get('structure_complete', False)}
References Populated: {validation.get('references_populated', False)}

Research Question Length: {len(research_question)} characters
Scientist Findings Length: {len(scientist_findings)} characters

Sections Found: {', '.join(validation.get('found_sections', []))}
Missing Sections: {', '.join(validation.get('missing_sections', []))}

Generated on: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-->

"""
        
        # Combine metadata and paper content
        full_content = metadata_header + paper_content
        
        # Save to file
        output_path = Path(output_path)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(full_content)
            
        print(f"âœ… Paper saved to: {output_path}")
        return str(output_path)
        
    except Exception as e:
        print(f"âŒ Error saving paper: {e}")
        raise


def print_validation_report(validation: dict):
    """Print a comprehensive validation report."""
    
    print(f"ğŸ“ Word Count: {validation.get('word_count', 'Unknown')}")
    print(f"ğŸ”— Citations: {validation.get('citation_count', 0)}")
    print(f"ğŸ“Š Figures: {validation.get('figure_suggestions', 0)}")
    
    print("\nğŸ“‹ Sections Analysis:")
    found_sections = validation.get('found_sections', [])
    required_sections = validation.get('required_sections', [])
    
    for section in required_sections:
        status = "âœ…" if section in found_sections else "âŒ"
        print(f"  {status} {section.capitalize()}")
    
    missing = validation.get('missing_sections', [])
    if missing:
        print(f"\nâš ï¸  Missing Sections: {', '.join(missing)}")
    
    print(f"\nğŸ—ï¸  Structure Complete: {'âœ… Yes' if validation.get('structure_complete') else 'âŒ No'}")
    print(f"ğŸ“š References Quality: {'âœ… Good' if validation.get('references_populated') else 'âŒ Needs Work'}")


def main():
    """Main function to handle command line arguments and generate paper."""
    parser = argparse.ArgumentParser(
        description="Generate academic papers with global sentence-level citations",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Global citations (default - recommended)
  python src/write_paper_re.py -q question.txt -r results.md
  
  # Traditional citations
  python src/write_paper_re.py -q question.txt -r results.md --traditional
  
  # Custom parameters
  python src/write_paper_re.py -q question.txt -r results.md -w 5000 --model openai/gpt-4o
  
  # Direct text input with verbose output
  python src/write_paper_re.py --question "Research question?" --results "Findings..." --verbose
        """
    )
    
    # Input arguments
    input_group = parser.add_mutually_exclusive_group(required=True)
    input_group.add_argument(
        "-q", "--question-file", 
        type=str,
        help="Path to file containing research question (.txt, .md)"
    )
    input_group.add_argument(
        "--question",
        type=str,
        help="Research question as direct text input"
    )
    
    results_group = parser.add_mutually_exclusive_group(required=True)
    results_group.add_argument(
        "-r", "--results-file",
        type=str,
        help="Path to file containing scientist results (.md, .txt)"
    )
    results_group.add_argument(
        "--results",
        type=str,
        help="Scientist results as direct text input"
    )
    
    # Output arguments
    parser.add_argument(
        "-o", "--output",
        type=str,
        default="generated_paper.md",
        help="Output file path (default: generated_paper.md)"
    )
    
    parser.add_argument(
        "-w", "--words",
        type=int,
        default=3000,
        help="Target word count (default: 3000)"
    )
    
    # Citation arguments
    citation_group = parser.add_mutually_exclusive_group()
    citation_group.add_argument(
        "--global-citations",
        action="store_true",
        default=False,
        help="Use global sentence-level citations (default: False)"
    )

    parser.add_argument(
        "--citation",
        type=Path,
        help="Path to the citation file (CSV) to add to the References section"
    )
    
    # Model arguments
    parser.add_argument(
        "--model",
        type=str,
        default="openai/gpt-4o",
        help="Model to use (default: openai/gpt-4o)"
    )
    
    parser.add_argument(
        "--provider",
        type=str,
        default="openrouter",
        choices=["openrouter", "anthropic"],
        help="API provider (default: openrouter)"
    )
    
    # Other arguments
    parser.add_argument(
        "--verbose",
        action="store_true",
        help="Enable verbose output"
    )
    
    args = parser.parse_args()
    
    api_key = os.getenv("OPENROUTER_API_KEY")
    if not api_key:
        print("âŒ ERROR: OPENROUTER_API_KEY environment variable not set")
        sys.exit(1)

    # Print header
    print("ğŸš€ REFACTORED ACADEMIC PAPER GENERATOR")
    print("=" * 70)
    
    try:
        # Load research question
        if args.question_file:
            print(f"\nğŸ“– Loading research question from: {args.question_file}")
            research_question = load_content_from_file(args.question_file)
        else:
            research_question = args.question
            print(f"ğŸ“– Using direct research question ({len(research_question)} chars)")
        
        # Load scientist results
        if args.results_file:
            print(f"ğŸ“Š Loading scientist results from: {args.results_file}")
            scientist_findings = load_content_from_file(args.results_file)
        else:
            scientist_findings = args.results
            print(f"ğŸ“Š Using direct scientist results ({len(scientist_findings)} chars)")
        
        # Initialize paper solver
        print("\nğŸ¤– Initializing PaperSolver...")
        print(f"   API_LEY: {api_key[:20]}**")
        print(f"   Model: {args.model}")
        print(f"   Provider: {args.provider}")
        
        solver = PaperSolver(
            api_key=api_key,
            model=args.model,
            provider=args.provider,
            citation=args.citation,
            use_global_citations=args.global_citations
        )
        print("âœ… Paper solver initialized successfully")
        
        # Generate paper
        print(f"\nğŸ“ Generating paper (target: {args.words} words)...")
        print("This may take several minutes...")
        
        if args.verbose:
            print(f"  Target word count: {args.words}")
            print(f"  Question length: {len(research_question)} chars")
            print(f"  Results length: {len(scientist_findings)} chars")
        
        try:
            paper_content, validation = solver.generate_and_validate_paper(
                research_question=research_question,
                scientist_findings=scientist_findings,
                target_word_count=args.words,
                save_to_file=False  # We'll save with metadata
            )
            print("âœ… Paper generation completed!")
            
            # Print validation report
            print_validation_report(validation)

        except Exception as paper_error:
            print(f"\nâŒ Paper generation failed: {paper_error}")
            if args.verbose:
                import traceback
                traceback.print_exc()
            
            # Create minimal validation for error case
            validation = {
                'word_count': 0,
                'citation_count': 0,
                'figure_suggestions': 0,
                'found_sections': [],
                'required_sections': ['abstract', 'introduction', 'methods', 'results', 'discussion', 'conclusion', 'references'],
                'missing_sections': ['abstract', 'introduction', 'methods', 'results', 'discussion', 'conclusion', 'references'],
                'structure_complete': False,
                'references_populated': False
            }
            
            print("\nâŒ Cannot continue due to paper generation failure")
            sys.exit(1)
        
        # Save paper with metadata
        print(f"\nğŸ’¾ Saving paper with metadata to: {args.output}")
        saved_path = save_paper_with_metadata(
            paper_content, args.output, research_question, 
            scientist_findings, validation
        )
        
        # Final summary
        print("\nğŸ‰ SUCCESS!")
        print("=" * 60)
        print(f"ğŸ“„ Paper Generated: {saved_path}")
        print(f"ğŸ“ Length: {validation.get('word_count', 0)} words")
        print(f"ğŸ”— Citations: {validation.get('citation_count', 0)}")
        print(f"ğŸ“Š Structure: {'Complete' if validation.get('structure_complete') else 'Incomplete'}")
        
        # Quality assessment
        if (validation.get('structure_complete') and 
            validation.get('references_populated') and 
            validation.get('citation_count', 0) > 0):
            print("\nğŸ… PAPER QUALITY: EXCELLENT!")
        elif validation.get('structure_complete'):
            print("\nğŸ”§ PAPER QUALITY: Good structure, enhance citations")
        else:
            print("\nâš ï¸  PAPER QUALITY: Review and improve structure")

        
    except KeyboardInterrupt:
        print("\n\nâš ï¸  Generation interrupted by user")
        sys.exit(1)
        
    except Exception as e:
        print(f"\nâŒ ERROR: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()
